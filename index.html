<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Language Flashcards</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .preserve-3d { transform-style: preserve-3d; }
    .backface-hidden { backface-visibility: hidden; }
    .rotate-y-180 { transform: rotateY(180deg); }
    canvas { touch-action: none; user-select: none; }
  </style>
</head>
<body class="bg-gradient-to-br from-indigo-50 to-purple-50 min-h-screen">
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useMemo, useRef } = React;

    function FlashcardApp() {
      const [cards, setCards] = useState([]);
      const [allCards, setAllCards] = useState([]);
      const [sourcesCount, setSourcesCount] = useState(0);
      const [idx, setIdx] = useState(0);
      const [flipped, setFlipped] = useState(false);
      const [loading, setLoading] = useState(false);
      const [err, setErr] = useState('');
      const [token, setToken] = useState('');
      const [dbId, setDbId] = useState('');
      const [srcId, setSrcId] = useState('');
      const [configured, setConfigured] = useState(false);

      const [selectedLang, setSelectedLang] = useState('All');
      const [sortBy, setSortBy] = useState('Newest');
      const [languages, setLanguages] = useState([]);
      const [wordFirst, setWordFirst] = useState(true);
      const [practiceMode, setPracticeMode] = useState('none');
      const [userInput, setUserInput] = useState('');
      const canvasRef = useRef(null);
      const [isEraser, setIsEraser] = useState(false);

      useEffect(() => {
        const p = new URLSearchParams(location.search);
        const t = p.get('token'), d = p.get('database'), s = p.get('source');
        if (t && d) {
          setToken(t); setDbId(d); setSrcId(s||'');
          fetchCards(t, d, s||null);
        }
      }, []);

      const fetchCards = async (tk, db, specificSrc = null) => {
        setLoading(true); setErr('');
        try {
          const r = await fetch('/api/notion', {
            method: 'POST',
            headers: {'Content-Type':'application/json'},
            body: JSON.stringify({token:tk, databaseId:db, sourceId:specificSrc})
          });
          const data = await r.json();
          if (!r.ok) throw new Error(data.error||'load failed');

          let all = [];
          if (data.data_sources?.length) {
            if (specificSrc) {
              all = data.data_sources[0].results||[];
              setSourcesCount(1);
            } else {
              all = data.data_sources.flatMap(s=>s.results||[]);
              setSourcesCount(data.data_sources.length);
            }
          } else {
            all = data.results||[];
            setSourcesCount(1);
          }

          const fmt = all
            .filter(p => p.properties.Word?.title?.[0]?.plain_text)
            .map(p => {
              const examples = (p.properties['Example Sentence']?.relation || [])
                .map(rel => rel.title?.[0]?.plain_text)
                .filter(Boolean)
                .map(t => `"${t}"`)
                .join(' | ') || '';

              const lang = p.properties.Language?.select?.name || 'Unknown';
              const date = p.properties['Date Added']?.date?.start || '1970-01-01';

              return {
                id: p.id,
                word: p.properties.Word.title[0].plain_text,
                translation: p.properties.Translation?.rich_text?.[0]?.plain_text || p.properties.Translation?.text?.[0]?.plain_text || '',
                pron: p.properties.Pronunciation?.text?.[0]?.plain_text || p.properties.Pronunciation?.rich_text?.[0]?.plain_text || '',
                examples,
                lang,
                date,
              };
            });

          const uniq = fmt.filter((c,i,a) => a.findIndex(x=>x.id===c.id)===i);
          setAllCards(uniq);

          const langs = ['All', ...new Set(uniq.map(c => c.lang))].sort();
          setLanguages(langs);

          setConfigured(true);
          if (!uniq.length) setErr('No cards – check property names');
        } catch (e) { setErr(e.message); }
        finally { setLoading(false); }
      };

      const filteredAndSorted = useMemo(() => {
        let filtered = selectedLang === 'All' ? allCards : allCards.filter(c => c.lang === selectedLang);
        switch (sortBy) {
          case 'Newest': return filtered.sort((a, b) => new Date(b.date) - new Date(a.date));
          case 'Oldest': return filtered.sort((a, b) => new Date(a.date) - new Date(b.date));
          case 'A-Z': return filtered.sort((a, b) => a.word.localeCompare(b.word));
          case 'Z-A': return filtered.sort((a, b) => b.word.localeCompare(a.word));
          default: return filtered;
        }
      }, [allCards, selectedLang, sortBy]);

      useEffect(() => {
        setCards(filteredAndSorted);
        setIdx(0);
        setFlipped(false);
        setUserInput('');
        if (canvasRef.current) {
          const ctx = canvasRef.current.getContext('2d');
          ctx.clearRect(0, 0, canvasRef.current.width, canvasRef.current.height);
        }
      }, [filteredAndSorted]);

      const next = () => {
        setFlipped(false);
        setUserInput('');
        if (canvasRef.current) {
          const ctx = canvasRef.current.getContext('2d');
          ctx.clearRect(0, 0, canvasRef.current.width, canvasRef.current.height);
        }
        setTimeout(() => setIdx(i => (i+1) % cards.length), 300);
      };

      const prev = () => {
        setFlipped(false);
        setUserInput('');
        if (canvasRef.current) {
          const ctx = canvasRef.current.getContext('2d');
          ctx.clearRect(0, 0, canvasRef.current.width, canvasRef.current.height);
        }
        setTimeout(() => setIdx(i => (i-1 + cards.length) % cards.length), 300);
      };

      // Canvas Drawing — ZERO OFFSET
      useEffect(() => {
        if (practiceMode !== 'draw' || !canvasRef.current) return;

        const canvas = canvasRef.current;
        const ctx = canvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();

        // Set actual size in memory (scaled for retina)
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        ctx.scale(dpr, dpr);

        let drawing = false;

        const getCoords = (e) => {
          const clientX = e.clientX || (e.touches?.[0]?.clientX);
          const clientY = e.clientY || (e.touches?.[0]?.clientY);
          return {
            x: (clientX - rect.left) * (canvas.width / rect.width),
            y: (clientY - rect.top) * (canvas.height / rect.height)
          };
        };

        const start = (e) => {
          drawing = true;
          const { x, y } = getCoords(e);
          ctx.beginPath();
          ctx.moveTo(x / dpr, y / dpr);
        };

        const draw = (e) => {
          if (!drawing) return;
          const { x, y } = getCoords(e);

          ctx.globalCompositeOperation = isEraser ? 'destination-out' : 'source-over';
          ctx.lineWidth = isEraser ? 20 : 3;
          ctx.lineCap = 'round';
          ctx.strokeStyle = isEraser ? '' : '#4f46e5';

          ctx.lineTo(x / dpr, y / dpr);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(x / dpr, y / dpr);
        };

        const stop = () => { drawing = false; };

        canvas.addEventListener('mousedown', start);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stop);
        canvas.addEventListener('mouseout', stop);

        canvas.addEventListener('touchstart', (e) => { e.preventDefault(); start(e.touches[0]); });
        canvas.addEventListener('touchmove', (e) => { e.preventDefault(); draw(e.touches[0]); });
        canvas.addEventListener('touchend', stop);

        return () => {
          canvas.removeEventListener('mousedown', start);
          canvas.removeEventListener('mousemove', draw);
          canvas.removeEventListener('mouseup', stop);
          canvas.removeEventListener('mouseout', stop);
        };
      }, [practiceMode, isEraser]);

      const clearCanvas = () => {
        if (canvasRef.current) {
          const ctx = canvasRef.current.getContext('2d');
          const rect = canvasRef.current.getBoundingClientRect();
          ctx.clearRect(0, 0, rect.width, rect.height);
        }
      };

      if (!configured) return (
        <div className="min-h-screen flex items-center justify-center p-4">
          <div className="bg-white rounded-xl shadow p-6 w-full max-w-md space-y-4">
            <h1 className="text-2xl font-bold text-center">Flashcards</h1>
            <input type="password" placeholder="Notion token" value={token} onChange={e=>setToken(e.target.value)} className="w-full p-2 border rounded"/>
            <input type="text" placeholder="Database ID" value={dbId} onChange={e=>setDbId(e.target.value)} className="w-full p-2 border rounded"/>
            <input type="text" placeholder="Source ID (optional)" value={srcId} onChange={e=>setSrcId(e.target.value)} className="w-full p-2 border rounded"/>
            <button onClick={()=>fetchCards(token,dbId,srcId||null)} disabled={loading||!token||!dbId}
                    className="w-full bg-indigo-600 text-white py-2 rounded disabled:opacity-50">
              {loading?'Loading…':'Load'}
            </button>
            {err && <p className="text-red-600">{err}</p>}
          </div>
        </div>
      );

      if (!cards.length) return <div className="min-h-screen flex items-center justify-center"><p>No cards.</p></div>;

      const c = cards[idx];
      const frontText = wordFirst ? c.word : c.translation;
      const backText = wordFirst ? c.translation : c.word;

      return (
        <div className="min-h-screen flex flex-col items-center justify-center p-4">
          <div className="w-full max-w-lg">
            <div className="mb-4 flex gap-2 items-center flex-wrap text-sm">
              <select value={selectedLang} onChange={e => setSelectedLang(e.target.value)} className="px-3 py-1 border rounded">
                {languages.map(l => <option key={l} value={l}>{l === 'All' ? 'All Languages' : l}</option>)}
              </select>
              <select value={sortBy} onChange={e => setSortBy(e.target.value)} className="px-3 py-1 border rounded">
                <option>Newest</option><option>Oldest</option><option>A-Z</option><option>Z-A</option>
              </select>
              <label className="flex items-center gap-2 cursor-pointer">
                <input type="checkbox" checked={!wordFirst} onChange={e => setWordFirst(!e.target.checked)} className="w-4 h-4 text-indigo-600 rounded"/>
                <span>Translation first</span>
              </label>
              <span className="text-gray-600 ml-auto">{cards.length} card{cards.length > 1 ? 's' : ''}</span>
            </div>

            <div className="mb-4 flex gap-2 justify-center text-sm">
              <button onClick={() => setPracticeMode('none')} className={`px-3 py-1 rounded ${practiceMode === 'none' ? 'bg-indigo-600 text-white' : 'bg-white border'}`}>Just Flip</button>
              <button onClick={() => setPracticeMode('text')} className={`px-3 py-1 rounded ${practiceMode === 'text' ? 'bg-indigo-600 text-white' : 'bg-white border'}`}>Write</button>
              <button onClick={() => setPracticeMode('draw')} className={`px-3 py-1 rounded ${practiceMode === 'draw' ? 'bg-indigo-600 text-white' : 'bg-white border'}`}>Draw</button>
            </div>

            {practiceMode === 'draw' && (
              <div className="mb-4 flex gap-2 justify-center">
                <button onClick={() => setIsEraser(false)} className={`px-3 py-1 rounded text-xs ${!isEraser ? 'bg-indigo-600 text-white' : 'bg-white border'}`}>Pen</button>
                <button onClick={() => setIsEraser(true)} className={`px-3 py-1 rounded text-xs ${isEraser ? 'bg-red-600 text-white' : 'bg-white border'}`}>Eraser</button>
                <button onClick={clearCanvas} className="px-3 py-1 rounded text-xs bg-gray-600 text-white">Clear</button>
              </div>
            )}

            {/* FLASHCARD */}
            <div className="relative h-80 cursor-pointer mb-6" style={{perspective:'1000px'}} onClick={() => {
              if (practiceMode === 'none' || flipped) setFlipped(!flipped);
            }}>
              <div className={`absolute inset-0 transition-transform duration-600 preserve-3d ${flipped?'rotate-y-180':''}`} style={{transformStyle:'preserve-3d'}}>
                <div className="absolute inset-0 backface-hidden bg-white rounded-2xl shadow-xl flex flex-col items-center justify-center p-8 border-2 border-indigo-200">
                  <div className="text-4xl font-bold text-indigo-700">{frontText}</div>
                  <p className="text-sm text-gray-500 mt-4">
                    {practiceMode !== 'none' && !flipped ? 'Answer below, then press "Show Answer"' : 'Click to flip'}
                  </p>
                </div>

                <div className="absolute inset-0 backface-hidden bg-gradient-to-br from-indigo-500 to-purple-600 rounded-2xl shadow-xl flex flex-col items-center justify-center p-6 text-white rotate-y-180 overflow-y-auto">
                  <div className="text-3xl font-bold mb-2">{backText}</div>
                  {c.pron && <div className="text-lg italic opacity-90 mb-3">/{c.pron}/</div>}
                  {c.examples && (
                    <div className="mt-3 text-sm opacity-80 text-center max-w-xs">
                      <p className="font-semibold mb-1">Examples:</p>
                      <p className="italic">{c.examples}</p>
                    </div>
                  )}
                  {practiceMode !== 'none' && (
                    <div className="mt-4 p-3 bg-white/20 rounded-lg w-full max-w-xs text-sm">
                      <p className="font-semibold">Your Answer:</p>
                      {practiceMode === 'text' ? (
                        <p className="italic mt-1 break-words">{userInput || '(empty)'}</p>
                      ) : (
                        <div className="mt-1 bg-white rounded p-1">
                          <canvas
                            ref={el => el && canvasRef.current && el.getContext('2d').drawImage(canvasRef.current, 0, 0, 200, 75)}
                            width={200} height={75} className="w-full border"
                          />
                        </div>
                      )}
                    </div>
                  )}
                  <p className="text-sm opacity-90 mt-6">Click to flip</p>
                </div>
              </div>
            </div>

            {/* PRACTICE AREA BELOW */}
            {practiceMode !== 'none' && (
              <div className="mb-6 p-4 bg-white rounded-lg shadow border">
                {practiceMode === 'text' ? (
                  <textarea
                    value={userInput}
                    onChange={e => setUserInput(e.target.value)}
                    placeholder="Type your answer here..."
                    className="w-full h-24 p-2 border rounded resize-none focus:outline-none focus:ring-2 focus:ring-indigo-500"
                  />
                ) : (
                  <canvas
                    ref={canvasRef}
                    width={400}
                    height={150}
                    className="w-full border rounded bg-gray-50"
                    style={{ touchAction: 'none', userSelect: 'none' }}
                  />
                )}
              </div>
            )}

            {/* SHOW ANSWER */}
            {practiceMode !== 'none' && !flipped && (
              <div className="text-center mb-6">
                <button
                  onClick={() => setFlipped(true)}
                  className="px-8 py-3 bg-indigo-600 text-white rounded-lg shadow-lg hover:bg-indigo-700 text-lg font-medium"
                >
                  Show Answer
                </button>
              </div>
            )}

            <div className="flex justify-between">
              <button onClick={prev} className="px-5 py-2 bg-white rounded shadow">Previous</button>
              <button onClick={next} className="px-5 py-2 bg-white rounded shadow">Next</button>
            </div>
          </div>
        </div>
      );
    }
    ReactDOM.render(<FlashcardApp />, document.getElementById('root'));
  </script>
</body>
</html>
