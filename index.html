<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Language Flashcards - Single/Multi-Source</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .flip-enter { transform: rotateY(0deg); }
    .flip-enter-active { transform: rotateY(180deg); transition: transform 0.6s; }
    .flip-exit { transform: rotateY(180deg); }
    .flip-exit-active { transform: rotateY(0deg); transition: transform 0.6s; }
  </style>
</head>
<body class="bg-gradient-to-br from-indigo-50 to-purple-50 min-h-screen">
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect } = React;

    function FlashcardApp() {
      const [cards, setCards] = useState([]);
      const [sourcesCount, setSourcesCount] = useState(0);
      const [currentIndex, setCurrentIndex] = useState(0);
      const [flipped, setFlipped] = useState(false);
      const [loading, setLoading] = useState(false);
      const [error, setError] = useState('');
      const [notionToken, setNotionToken] = useState('');
      const [databaseId, setDatabaseId] = useState('');
      const [sourceId, setSourceId] = useState('');
      const [isConfigured, setIsConfigured] = useState(false);

      // Load from URL params on mount
      useEffect(() => {
        const params = new URLSearchParams(window.location.search);
        const token = params.get('token');
        const dbId = params.get('database');
        const srcId = params.get('source');
        if (token && dbId) {
          setNotionToken(token);
          setDatabaseId(dbId);
          setSourceId(srcId || '');
          fetchCards(token, dbId, srcId || null);
        }
      }, []);

      const fetchCards = async (token, dbId, specificSourceId = null) => {
        setLoading(true);
        setError('');
        try {
          const res = await fetch('/api/notion', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ token, databaseId: dbId, sourceId: specificSourceId })
          });

          if (!res.ok) {
            const err = await res.json();
            throw new Error(err.error || 'Failed to load flashcards');
          }

          const data = await res.json();

          let allResults;
          if (data.data_sources && data.data_sources.length > 0) {
            if (specificSourceId) {
              allResults = data.data_sources[0]?.results || [];
              setSourcesCount(1);
            } else {
              allResults = data.data_sources.flatMap(source => source.results || []);
              setSourcesCount(data.data_sources.length);
            }
          } else {
            allResults = data.results || [];
            setSourcesCount(1);
          }

          /* ---------- NEW: extract extra fields ---------- */
          const formatted = allResults
            .filter(page => 
              page.properties.Word?.title?.[0]?.plain_text &&
              page.properties.Translation?.rich_text?.[0]?.plain_text
            )
            .map(page => ({
              id: page.id,
              front: page.properties.Word.title[0].plain_text,
              back: page.properties.Translation.rich_text[0].plain_text,
              pronunciation: page.properties.Pronunciation?.rich_text?.[0]?.plain_text || '',
              exampleSentenceIds: page.properties["Example Sentence"]?.relation?.map(r => r.id) || [],
              source: page.data_source_id || 'default'
            }));

          // Dedupe by ID
          const uniqueCards = formatted.filter((card, index, self) => 
            index === self.findIndex(c => c.id === card.id)
          );

          setCards(uniqueCards);
          setIsConfigured(true);
          if (uniqueCards.length === 0) setError('No valid flashcards found. Check property names in the source.');
        } catch (err) {
          setError(err.message);
        } finally {
          setLoading(false);
        }
      };

      const handleConnect = () => {
        if (notionToken && databaseId) fetchCards(notionToken, databaseId, sourceId || null);
      };

      const nextCard = () => {
        setFlipped(false);
        setTimeout(() => {
          setCurrentIndex((prev) => (prev + 1) % cards.length);
        }, 300);
      };

      const prevCard = () => {
        setFlipped(false);
        setTimeout(() => {
          setCurrentIndex((prev) => (prev - 1 + cards.length) % cards.length);
        }, 300);
      };

      /* ---------- CONFIG UI (unchanged) ---------- */
      if (!isConfigured) { … }   // (same as before)

      if (cards.length === 0) { … } // (same as before)

      const card = cards[currentIndex];

      return (
        <div className="min-h-screen flex flex-col items-center justify-center p-4 md:p-8">
          <div className="w-full max-w-lg">
            {/* Progress */}
            <div className="flex justify-between items-center mb-6 text-sm text-gray-600">
              <span>Card {currentIndex + 1} of {cards.length} <span className="text-indigo-500">(from {sourcesCount} source{sourcesCount > 1 ? 's' : ''})</span></span>
              <button
                onClick={() => { setCards([...cards].sort(() => Math.random() - 0.5)); setCurrentIndex(0); setFlipped(false); }}
                className="flex items-center gap-1 hover:text-indigo-600 transition-colors"
              >
                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2" />
                </svg>
                Shuffle
              </button>
            </div>

            {/* Flashcard */}
            <div
              className="relative h-80 cursor-pointer preserve-3d"
              style={{ perspective: '1000px' }}
              onClick={() => setFlipped(!flipped)}
            >
              <div
                className={`absolute inset-0 w-full h-full transition-transform duration-600 preserve-3d ${flipped ? 'rotate-y-180' : ''}`}
                style={{ transformStyle: 'preserve-3d' }}
              >
                {/* Front */}
                <div className="absolute inset-0 backface-hidden bg-white rounded-2xl shadow-xl flex flex-col items-center justify-center p-8 border-2 border-indigo-200">
                  <div className="text-4xl font-bold text-indigo-700 mb-4">{card.front}</div>
                  <p className="text-sm text-gray-500">Click to flip</p>
                </div>

                {/* Back – now with Pronunciation & Example Sentence */}
                <div className="absolute inset-0 backface-hidden bg-gradient-to-br from-indigo-500 to-purple-600 rounded-2xl shadow-xl flex flex-col items-center justify-center p-6 text-white rotate-y-180 overflow-y-auto">
                  <div className="text-3xl font-bold mb-3">{card.back}</div>

                  {/* Pronunciation – only if not empty */}
                  {card.pronunciation && (
                    <div className="mb-4 text-lg italic opacity-90">
                      /{card.pronunciation}/
                    </div>
                  )}

                  {/* Example Sentence – fetch the related page title */}
                  {card.exampleSentenceIds.length > 0 && (
                    <ExampleSentenceFetcher
                      token={notionToken}
                      ids={card.exampleSentenceIds}
                    />
                  )}

                  <p className="text-sm opacity-90 mt-4">Click to flip</p>
                </div>
              </div>
            </div>

            {/* Navigation */}
            <div className="flex justify-between mt-8">
              <button onClick={prevCard} className="flex items-center gap-2 px-5 py-3 bg-white text-gray-700 rounded-lg shadow hover:shadow-md transition-all">
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 19l-7-7 7-7" />
                </svg>
                Previous
              </button>

              <button onClick={nextCard} className="flex items-center gap-2 px-5 py-3 bg-white text-gray-700 rounded-lg shadow hover:shadow-md transition-all">
                Next
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
                </svg>
              </button>
            </div>

            <p className="text-center mt-6 text-sm text-gray-500">
              Tip: Click the card to reveal the answer
            </p>
          </div>
        </div>
      );
    }

    /* ---------- NEW: ExampleSentenceFetcher component ---------- */
    const ExampleSentenceFetcher = React.memo(({ token, ids }) => {
      const [sentences, setSentences] = useState([]);
      const [loading, setLoading] = useState(true);
      const [error, setError] = useState('');

      useEffect(() => {
        const fetchSentences = async () => {
          setLoading(true);
          setError('');
          try {
            const promises = ids.map(id =>
              fetch('/api/notion-page', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ token, pageId: id })
              }).then(r => r.json())
            );
            const results = await Promise.all(promises);

            const texts = results
              .filter(p => p?.properties?.title?.title?.[0]?.plain_text)
              .map(p => p.properties.title.title[0].plain_text);

            setSentences(texts);
          } catch (e) {
            setError('Failed to load example');
          } finally {
            setLoading(false);
          }
        };
        fetchSentences();
      }, [token, ids]);

      if (loading) return <div className="text-sm opacity-80">Loading example…</div>;
      if (error) return <div className="text-sm opacity-80">{error}</div>;

      return (
        <div className="mt-3 text-center">
          {sentences.map((s, i) => (
            <p key={i} className="text-base opacity-90 mb-1">
              “{s}”
            </p>
          ))}
        </div>
      );
    });

    /* ---------- CSS for 3D flip (unchanged) ---------- */
    const style = document.createElement('style');
    style.innerHTML = `
      .preserve-3d { transform-style: preserve-3d; }
      .backface-hidden { backface-visibility: hidden; }
      .rotate-y-180 { transform: rotateY(180deg); }
    `;
    document.head.appendChild(style);

    ReactDOM.render(<FlashcardApp />, document.getElementById('root'));
  </script>
</body>
</html>
