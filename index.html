<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Language Flashcards</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .preserve-3d { transform-style: preserve-3d; }
    .backface-hidden { backface-visibility: hidden; }
    .rotate-y-180 { transform: rotateY(180deg); }
  </style>
</head>
<body class="bg-gradient-to-br from-indigo-50 to-purple-50 min-h-screen">
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useMemo } = React;

    function FlashcardApp() {
      const [cards, setCards] = useState([]);
      const [allCards, setAllCards] = useState([]);
      const [sourcesCount, setSourcesCount] = useState(0);
      const [idx, setIdx] = useState(0);
      const [flipped, setFlipped] = useState(false);
      const [loading, setLoading] = useState(false);  // Fixed: was "the [loading..."
      const [err, setErr] = useState('');
      const [token, setToken] = useState('');
      const [dbId, setDbId] = useState('');
      const [srcId, setSrcId] = useState('');
      const [configured, setConfigured] = useState(false);

      // Filter & Sort
      const [selectedLang, setSelectedLang] = useState('All');
      const [sortBy, setSortBy] = useState('Newest');
      const [languages, setLanguages] = useState([]);

      useEffect(() => {
        const p = new URLSearchParams(location.search);
        const t = p.get('token'), d = p.get('database'), s = p.get('source');
        if (t && d) {
          setToken(t); setDbId(d); setSrcId(s||'');
          fetchCards(t, d, s||null);
        }
      }, []);

      const fetchCards = async (tk, db, specificSrc = null) => {
        setLoading(true); setErr('');
        try {
          const r = await fetch('/api/notion', {
            method: 'POST',
            headers: {'Content-Type':'application/json'},
            body: JSON.stringify({token:tk, databaseId:db, sourceId:specificSrc})
          });
          const data = await r.json();
          if (!r.ok) throw new Error(data.error||'load failed');

          let all = [];
          if (data.data_sources?.length) {
            if (specificSrc) {
              all = data.data_sources[0].results||[];
              setSourcesCount(1);
            } else {
              all = data.data_sources.flatMap(s=>s.results||[]);
              setSourcesCount(data.data_sources.length);
            }
          } else {
            all = data.results||[];
            setSourcesCount(1);
          }

          const fmt = all
            .filter(p => p.properties.Word?.title?.[0]?.plain_text)
            .map(p => {
              const examples = (p.properties['Example Sentence']?.relation || [])
                .map(rel => rel.title?.[0]?.plain_text)
                .filter(Boolean)
                .map(t => `“${t}”`)
                .join(' | ') || '';

              const lang = p.properties.Language?.select?.name || 'Unknown';
              const date = p.properties['Date Added']?.date?.start || '1970-01-01';

              return {
                id: p.id,
                front: p.properties.Word.title[0].plain_text,
                back: p.properties.Translation?.rich_text?.[0]?.plain_text || p.properties.Translation?.text?.[0]?.plain_text || '',
                pron: p.properties.Pronunciation?.text?.[0]?.plain_text || p.properties.Pronunciation?.rich_text?.[0]?.plain_text || '',
                examples,
                lang,
                date,
              };
            });

          const uniq = fmt.filter((c,i,a) => a.findIndex(x=>x.id===c.id)===i);
          setAllCards(uniq);

          const langs = ['All', ...new Set(uniq.map(c => c.lang))].sort();
          setLanguages(langs);

          setConfigured(true);
          if (!uniq.length) setErr('No cards – check property names');
        } catch (e) { setErr(e.message); }
        finally { setLoading(false); }
      };

      // Filter + Sort
      const filteredAndSorted = useMemo(() => {
        let filtered = selectedLang === 'All' ? allCards : allCards.filter(c => c.lang === selectedLang);
        switch (sortBy) {
          case 'Newest':
            return filtered.sort((a, b) => new Date(b.date) - new Date(a.date));
          case 'Oldest':
            return filtered.sort((a, b) => new Date(a.date) - new Date(b.date));
          case 'A-Z':
            return filtered.sort((a, b) => a.front.localeCompare(b.front));
          case 'Z-A':
            return filtered.sort((a, b) => b.front.localeCompare(a.front));
          default:
            return filtered;
        }
      }, [allCards, selectedLang, sortBy]);

      useEffect(() => {
        setCards(filteredAndSorted);
        setIdx(0);
      }, [filteredAndSorted]);

      const next = () => { setFlipped(false); setTimeout(() => setIdx(i => (i+1) % cards.length), 300); };
      const prev = () => { setFlipped(false); setTimeout(() => setIdx(i => (i-1 + cards.length) % cards.length), 300); };

      if (!configured) return (
        <div className="min-h-screen flex items-center justify-center p-4">
          <div className="bg-white rounded-xl shadow p-6 w-full max-w-md space-y-4">
            <h1 className="text-2xl font-bold text-center">Flashcards</h1>
            <input type="password" placeholder="Notion token" value={token} onChange={e=>setToken(e.target.value)} className="w-full p-2 border rounded"/>
            <input type="text" placeholder="Database ID" value={dbId} onChange={e=>setDbId(e.target.value)} className="w-full p-2 border rounded"/>
            <input type="text" placeholder="Source ID (optional)" value={srcId} onChange={e=>setSrcId(e.target.value)} className="w-full p-2 border rounded"/>
            <button onClick={()=>fetchCards(token,dbId,srcId||null)} disabled={loading||!token||!dbId}
                    className="w-full bg-indigo-600 text-white py-2 rounded disabled:opacity-50">
              {loading?'Loading…':'Load'}
            </button>
            {err && <p className="text-red-600">{err}</p>}
          </div>
        </div>
      );

      if (!cards.length) return <div className="min-h-screen flex items-center justify-center"><p>No cards.</p></div>;

      const c = cards[idx];
      return (
        <div className="min-h-screen flex flex-col items-center justify-center p-4">
          <div className="w-full max-w-lg">
            {/* FILTER & SORT BAR */}
            <div className="mb-4 flex gap-2 items-center flex-wrap">
              <select
                value={selectedLang}
                onChange={e => setSelectedLang(e.target.value)}
                className="px-3 py-1 border rounded text-sm"
              >
                {languages.map(l => (
                  <option key={l} value={l}>{l === 'All' ? 'All Languages' : l}</option>
                ))}
              </select>
              <select
                value={sortBy}
                onChange={e => setSortBy(e.target.value)}
                className="px-3 py-1 border rounded text-sm"
              >
                <option>Newest</option>
                <option>Oldest</option>
                <option>A-Z</option>
                <option>Z-A</option>
              </select>
              <span className="text-sm text-gray-600 ml-auto">{cards.length} card{cards.length > 1 ? 's' : ''}</span>
            </div>

            <div className="flex justify-between mb-4 text-sm">
              <span>Card {idx+1}/{cards.length} ({sourcesCount} source{sourcesCount>1?'s':''})</span>
              <button onClick={()=>{setCards([...cards].sort(()=>Math.random()-0.5));setIdx(0);}} className="underline">Shuffle</button>
            </div>

            <div className="relative h-80 cursor-pointer" style={{perspective:'1000px'}} onClick={()=>setFlipped(!flipped)}>
              <div className={`absolute inset-0 transition-transform duration-600 preserve-3d ${flipped?'rotate-y-180':''}`} style={{transformStyle:'preserve-3d'}}>
                {/* FRONT */}
                <div className="absolute inset-0 backface-hidden bg-white rounded-2xl shadow-xl flex flex-col items-center justify-center p-8 border-2 border-indigo-200">
                  <div className="text-4xl font-bold text-indigo-700">{c.front}</div>
                  <p className="text-sm text-gray-500 mt-4">Click to flip</p>
                </div>

                {/* BACK */}
                <div className="absolute inset-0 backface-hidden bg-gradient-to-br from-indigo-500 to-purple-600 rounded-2xl shadow-xl flex flex-col items-center justify-center p-6 text-white rotate-y-180 overflow-y-auto">
                  <div className="text-3xl font-bold mb-2">{c.back}</div>
                  {c.pron && <div className="text-lg italic opacity-90 mb-3">/{c.pron}/</div>}
                  {c.examples && (
                    <div className="mt-3 text-sm opacity-80 text-center max-w-xs">
                      <p className="font-semibold mb-1">Examples:</p>
                      <p className="italic">{c.examples}</p>
                    </div>
                  )}
                  <p className="text-sm opacity-90 mt-6">Click to flip</p>
                </div>
              </div>
            </div>

            <div className="flex justify-between mt-8">
              <button onClick={prev} className="px-5 py-2 bg-white rounded shadow">Previous</button>
              <button onClick={next} className="px-5 py-2 bg-white rounded shadow">Next</button>
            </div>
          </div>
        </div>
      );
    }
    ReactDOM.render(<FlashcardApp />, document.getElementById('root'));
  </script>
</body>
</html>
